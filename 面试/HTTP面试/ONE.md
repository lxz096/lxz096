### HTTP和HTTPS的区别，还有端口号

* HTTP的端口号为80;HTTPS的端口号为443;
* HTTPS就是一份安全加密版的HTTP+SSL/TLS;
* HTTP通常在应用层中;
  
### 为什么HTTPS更加安全

* 利用SSL/TLS协议传输保障通信安全。

### HTTP/2你知道多少？

* 引入服务器推送的概念。
* 允许服务器在客户端需要数据时主动推送到客户端缓存中
* HTTP/2提供了更多的加密支持。
* HTTP/2使用多路复用技术。
* 增加了头压缩，请求减小。

### HTTP常见状态码

* 100 表示继续
* 200 表示正常返回 OK
* 201 表示请求成功创建新的资源
* 202 服务器已经接受请求，但尚未处理
* 301 请求网页已经永久移动到新的位置
* 302 临时性重定向
* 303 临时性重定向 且以GET请求URL
* 304 上次请求后 且网页并未修改
* 400 服务器未理解其请求格式
* 401 表示请求未授权
* 403 表示禁止访问
* 404 未找到与URL地址相匹配的资源文件
* 500 服务器端错误
* 503 服务器过载或者维护中

### 完整HTTP事务流程

1. 域名解析
2. 发送TCP三次握手协议
3. 建立TCP连接后发送HTTP请求
4. 服务器响应HTTP请求，浏览器得到HTML代码
5. 浏览器解析HTML代码并且代码中的资源
6. 浏览器对页面进行渲染并呈现给用户

### 创建HTTP服务器

* 在Nodejs中 

``` JavaScript
var http = require('http');//加载模块中的请求
http.createServer(function(req,res){res.writeHead(200,{'Content-Type':'text/html'})} );
//200表示请求成功
//文档类型给浏览器识别用的
res.write('<meta charset="UTF-8"><h1>有课前端网</h1>')
//返回给客户端的HTML数据
res.send();
//结束输出流
.listen(3000)
//绑定3000

```

### 什么是HTTP

- 是客户端和服务器端的之间数据传输的格式规范，表示“超文本传输协议”

### HTTP无状态协议，如何克服HTTP无状态协议的缺陷

1. 无状态协议意味着对于事务处理没有记忆能力。缺少状态意味着如果需要后续处理，需要提供前面的信息。
2. 克服无状态协议的办法就是通过Cookie和会话保存信息。

### HTTP请求报文和响应报文的包含部分

* 请求报文包含部分
1. 请求行，请求方法，URL，HTTP版本信息
2. 请求首部字段
3. 请求内容实体

* 响应报文包含部分
1. 状态行，包含HTTP版本，状态码，状态码的原因短语。
2. 响应首部字段。
3. 响应内容实体。

### HTTP请求方式

1. GET：请求访问识别资源，可以通过URL，给服务器传递参数数据
2. POST：传输信息给服务器，功能与GET方法类似，但是传递的数据量不受限制
3. PUT：传输文件，报文主体中包含文件内容，保存到对应URL位置
4. HEAD：获取报文首部，与GET方法类似，只是不返回报文主体，一般适用于验证URI是否有效
5. DELETE：删除文件，与PUT方法相反，删除对应URL位置的文件
6. OPTIONS：查询相对应URI支持的HTTP方法

### HTTP协议中1.0和1.1的版本区别

* 1.0版本是在一次数据传输后就会关闭连接，下次再去重新请求就又要建立连接。
* 1.1引入了持续连接的概念。客户端可以连续发送多个请求，不需要每个响应信息的到来。

### HTTP首部字段的类型

1. 通用首部字段(请求报文和响应报文都会使用的首部字段)。
   - Date：创建报文时间
   - Connection：连接管理
   - Cache-Control：缓存的控制
   - Transfer-Encoding：报文主体的传输编码方式
2. 请求首部字段(请求报文会使用的首部字段)
   - Host：请求资源所在的服务器
   - Accept：可处理的媒体类型
   - Accept-Charset：可接受的字符集
   - Accept-Encoding：可接受的内容编码
   - Accept-Language：可接受的自然语言
3. 响应首部字段(响应报文会使用的首部字段)
   - Accept-Ranges：可接受的字节范围
   - Location：令客户端重新定向到的URL
   - Server：HTTP服务器的安装信息

4. 实体首部字段(请求报文与响应报文的实体部分使用的首部字段)
   - Allow：资源可支持的HTTP方法
   - Content-Type：实体主体的类型
   - Content-Encoding：实体主体使用的编码方式
   - Content-Language：实体主体的自然语言
   - Content-Length：实体主体的字节数
   - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

### HTTPS相比，HTTP的缺点

1. 通信使用明文，不加密
2. 不验证通信放身份
3. 无法验证报文的完整性
- HTTPS就是HTTP+加密处理(一般是SSL安全通信线路)+认证+完整性保护

### 优化HTTP请求
1. 利用负载均衡优化和加速HTTP应用请求
2. 利用HTTP缓存来优化网站请求

### HTTP协议的特征

- 支持客户端/服务器模式，简单快速，灵活，无连接，无状态

### HTTP1.1版本的新特性

1. 默认持久连接，节省通信量，一直保持连接，多次发送请求
2. 管线化，客户端同时发出多个HTTP请求，不用一个个等待响应
3. 断点续传原理。

### TCP传输的三次握手和四次挥手的策略

* 三次握手
  1. 发送端首先给接收端发送一个SYN包 
  2. 接收端收到后，回传一个带有SYN/ACK包，以确认信息
  3. 发送端再发送一个ACK包，表示握手结束
  4. 若握手阶段莫名中断，TCP会再次以相同顺序发送相同的数据包

* 中断四次挥手
  1. 主动关闭方发送一个FIN码，告诉被动关闭方我已经停止发送数据，但是主动关闭方依然还可以接受数据。
  2. 被动关闭方接受到FIN包后，给对方发送一个ACK确认，确认序号为收到的序号+1
  3. 第三次挥手被动关闭方给主动关闭方发送FIN，告诉它我会关闭数据传送，不会再给主动关闭方发送数据
  4. 主动关闭方收到FIN码后，给被动关闭方发送一个ACK，确认序号为收到序号+1，至此，完成四次挥手

### TCP和UDP的区别

* TCP基于连接协议，也就是说，正式收发数据之前必须建立一个可靠连接。一个TCP连接必须经过三次对话才能建立起来
* UDP是与TCP相对应的协议。面向非连接协议，不与对方建立连接，而是直接把数据发送过去。只是用少量的数据，可靠性不高的应用环境。

### 页面输入URL地址加载页面过程

1. 当发送给一个URL请求，浏览器会开启一个线程来处理，同时DNS服务器会尽行DNS解析，能够使得浏览器获得对应的IP地址
2. 浏览器和服务器通过三次握手协商建立以TCP连接通信
3. TCP/IP连接建立后，浏览器会向服务器发送GET请求，服务器找到资源会使用HTTP响应返回该资源，值为200HTTP的响应状态
4. 客户端下载服务器端的返回的资源，请求返回后进入浏览器模块，浏览器会解析HTML代码，去生成DOM Tree，其次根据CSS和JS生成相应的树

### 304缓存

1. 服务器首先请求生成ETag，服务器通过该记号会在稍后的请求中去判断是否有缓存，页面是否修改
2. 304是HTTP状态码，服务器会用它来表示文件并未修改，不返回内容，浏览器接收到该状态码会去使用缓存文件
3. 客户端请求A页面。服务器返回A页面，并且给A页面加上一个ETag。客户端缓存该页面和ETag，并进行展现
4. 客户端再次请求A页面，会将上次请求服务器返回的ETag一起传送给服务器
5. 服务器检查该ETag，并判断出该页面自上次请求后并未进行修改，直接返回一个304和一个空的响应体

### 什么是ETag

1. 浏览器缓存过去，向服务器发送请求，此时请求中会带上文件修改时间和ETag，然后进行资源更新判断
2. 服务器会根据浏览器传过来的文件修改时间，去判断浏览器上次请求后是否被修改，根据ETag去判断是否内容发生变化
3. 若两种条件判断出文件并未修改，服务器就会告诉浏览器可以继续使用缓存
4. 浏览器就会从本地缓存请求资源内容，这种情况就叫做协议缓存，浏览器和服务器之间有一次请求交互
5. 若修改时间和文件内容判断中有任意一个没有通过，则服务器会受理自此请求，并返回新的数据注意，只有GET请求才会缓存，而POST请求不会

### 说说ETag的应用

- ETag由服务器端生成。
- 客户端通过If-Match或者If-None-Match的这个条件判断请求来验证资源是否被修改
- 常见的If-None-Match
- 请求文件的流程：
  1. 第一次请求时，客户端发起HTTP GET请求，以获取一个文件，服务器处理请求，返回文件内容和请求头(包括ETag)，并返回200状态码，第二次请求时，客户端发起HTTP GET请求以获取文件
  2. 客户端同时发送一个为If-None-Match,这个头内容就是第一次请求时服务器返回的ETag，服务器判断发送过来的ETag和计算出来的ETag是否匹配
  3. 如果If-None-Match为False,不返回200，返回304，客户端继续使用本地缓存
  4. 如果服务器设置了Cache-Control：max-age和Expires，服务器端在完全匹配If-Modified-Since和If-None-Match后，即检查完修改时间和ETag之后，才能返回304

### Expires和Cache-Control的作用

* Expires要求服务器和客户端的时间严格同步。
* HTTP1.1引入了Cache-Control来克服Expires头的限制
* 如果max-age和Expires同时出现，那么max-age有更高的优先级
* 代码：
  
``` JavaScript
Cache-Control:no-cache,private,max-age=0
ETag:"8b4c-55f16e2e30000"
Expires:Thu,02 Dec 2027 11:37:56 GMT
Last-Modified:Wed,29 Nov 2017 03:39:44 
```

### 什么是反向代理

* 通过代理服务器接受互联网上的请求
* 然后将请求转发给内部网络上的服务器
* 最后把服务器得到的结果返回给客户端